*[Back to index](</readme.md>)*
___
## Contents
- [Contents](#contents)
- [Lists and Tuples](#lists-and-tuples)
- [Tuples](#tuples)
  - [Types](#types)
  - [Indexing](#indexing)
  - [Slicing](#slicing)
  - [Stride](#stride)
  - [Concatenation and immutability](#concatenation-and-immutability)
  - [Sorting](#sorting)
  - [Nesting](#nesting)
- [Tuple Exercises](#tuple-exercises)
- [Lists](#lists)
  - [Objectives:](#objectives)
  - [Indexing](#indexing-1)
  - [Quiz on Lists](#quiz-on-lists)

___
## Lists and Tuples
*Lists are mutable and can be changed. Tuples are fixed.*

Both lists and tuples are ordered data types (can be iterated over), are sequential, can contain multiple *types* and can be accessed via an index reference. Both are compound data types - data made up of multiple values or data types.  

The main difference between the two is that lists can be modified, whereas tuples cannot. This makes lists more flexible, however tuples are more memory efficient, making them the better option where the data will not need to change.

___
## Tuples
Tuples are an ordered sequence, they are very much like strings, except that unlike strings each element can contain multiple characters (different elements may be different types), rather than each character being an element.  

Tuples are expressed as comma-separated elements within parentheses. These elements can be of different types (string, float, integer etc.), but the type of the variable is tuple.  
Example tuple with string, integer and float.
```py
tuple = ("disco", 10, 1.2)

# Print the tuple
print(tuple)

# Print the type of the tuple
type(tuple)
```

Will output:  
```
('disco', 10, 1.2)
<class 'tuple'>
```
___
### Types
The type of a tuple is `tuple`, however each element within a tuple may have its own [type](/1%20Python%20Basics/1.2%20Types.md).

**tuple:**
|  **Element:**  |  "disco"  |    10    |    1.2    |
|----------------|-----------|----------|-----------|
|   **Type:**    |  string   |   int    |   float   |

The type of individual element can be printed:
```py
tuple = ("disco", 10, 1.2)

# Print the type of value on each index
print(type(tuple[0]))
print(type(tuple[1]))
print(type(tuple[2]))
```

Will output:  
```
<class 'str'>
<class 'int'>
<class 'float'>
```

___
### Indexing
As with [string indexing](/1%20Python%20Basics/1.4%20String%20Operations.md#indexing) the elements of a tuple can be accessed by the name of the tuple followed by a square bracket with the index number, negative indexing can also be used.

**tuple:**
|  **Element:**  |  "disco"  |    10    |    1.2    |
|----------------|-----------|----------|-----------|
|  **Index:**    |     0     |    1     |     2     |

```py
tuple = ("disco", 10, 1.2)

# Print the variable on different indexes
print(tuple[0])
print(tuple[1])
print(tuple[-1])
```

Will output:
```
disco
10
1.2
```

**Length**  
We can use the `len()` command to obtain the length of a tuple:
```py
tuple = ("disco", 10, 1.2)

# Print the length of the tuple
print(len(tuple))
```

Will output:
```
3
```

___
### Slicing
Like strings, tuples can be [sliced](/1%20Python%20Basics/1.4%20String%20Operations.md#slicing), to obtain multiple elements from a tuple the staring index is referenced, followed by the ending index +1, for example:
**tuple:**
|  **Element:**  |  "disco"  |    10    |    1.2    |
|----------------|-----------|----------|-----------|
|  **Index:**    |     0     |    1     |     2     |

```py
tuple = ("disco", 10, 1.2)

# Slice from index 0 to index 2 (i.e. take the first 2 elements)
tuple1[0:2]

```

Will output:
```
('disco', 10)
```

___
### Stride
Stride values can be used on tuples in the same was as [strings](/1%20Python%20Basics/1.4%20String%20Operations.md#stride) by following the required index range with the stride value:
**tuple1:**
|  **Element:**  | "disco" |  10  |  1.2  | "Cat" |  17.3  |  True  |
|----------------|---------|------|-------|-------|--------|--------|
|  **Index:**    |    0    |  1   |   2   |   3   |   4    |   5    |

```py
tuple1 = ("disco", 10, 1.2, "Cat", 17.3, True)

# Print every second element of the tuple
tuple1[0 : len(tuple1)+1 : 2]
```

Will output:
```
('disco', 1.2, 17.3)
```

[Loops *Needs Update 3.2](/x3%20Python%20Programming%20Fundamentals/x3.2%20Loops.md) can also be used to iterate through tuples.

___
### Concatenation and immutability
As with [string concatenation](/1%20Python%20Basics/1.4%20String%20Operations.md#concatenate-strings) tuples can be concatenated using the `+` sign:
```py
# Concatenate two tuples
tuple = tuple1 + ("Cat", 17.3, True)
print(tuple1)
```
Will output:
```
('disco', 10, 1.2, 'Cat', 17.3, True)
```

Tuples are immutable so they can't be modified directly. In order to "modify" the content of a tuple, a new tuple must be created. This can be done by replacing the tuple with a new one:
```py 
tuple = ("disco", 10, 1.2)
print("Original tuple: ", tuple)

# Replace 'tuple' with new 'tuple'
tuple = tuple + ("Cat", 17.3, True)
print("New tuple: ", tuple)
```
Will output:
```
Original tuple:  ('disco', 10, 1.2)
New tuple:  ('disco', 10, 1.2, 'Cat', 17.3, True)
```
*Note that only tuples or parts of tuples (slices) can be concatenated!*

If part of a tuple is to be modified, slicing can be used to take the parts of the tuple to be retained; and the new element inserted. This is then assigned to a new tuple (even if the new tuple is named the same as the old one.)
```py 
tuple = ('disco', 10, 1.2, 'Cat', 17.3, True)
print("Original tuple: ", tuple)

# Replace the element 'Cat' with 'Dog'
tuple1 = (tuple[0:3] + ("Dog",) + tuple[4:7])
print("New tuple: ", tuple1)
```
Will output:
```
Original tuple:  ('disco', 10, 1.2, 'Cat', 17.3, True)
New tuple:  ('disco', 10, 1.2, 'Dog', 17.3, True)
```

*Note that `("Dog")` is a string, and cannot be concatenated with the tuple slices. While placing a comma after `"Dog"` within parentheses, makes it a tuple: `("Dog",)`*
```py
a = "Dog"
b = ("Dog")
c = ("Dog",)
type(a)
<class 'str'>

type(b)
<class 'str'>

type(c)
<class 'tuple'>
```

___
### Sorting
As a consequence of immutability, manipulating a tuple requires creating a new tuple instead. The `sorted()` function leverages this, where the original tuple is read, the elements sorted and the result returned to a new tuple:
```py
# A sample tuple
Ratings = (0, 9, 6, 5, 10, 8, 9, 6, 2)

# Sort the tuple
RatingsSorted = sorted(Ratings)
RatingsSorted
```

Will output:
```
[0, 2, 5, 6, 6, 8, 9, 9, 10]
```

The `sorted()` function is highly flexible, but it requires the elements to be comparable (See [Types](/1%20Python%20Basics/1.2%20Types.md#types) for more information on comparability). For mixed or custom types, explicit sorting logic must be provided, for example using length:
```py
words = ["apple", "fig", "cherry"]
sorted(words) # Alphabetical (default) sort
sorted(words, key=len) # Sort by word length
```

Will output:
```
['apple', 'cherry', 'fig']
['fig', 'apple', 'cherry']
```
___
### Nesting  
A tuple can contain other tuples as well as other complex data types; this is called nesting. These elements can be accessed using standard indexing methods.  

**NestedT:**
|  **Element:**  | "1" |  2  | "pop", "rock"  | 3, 4 | "disco", (1, 2)  |
|----------------|-----|-----|----------------|------|------------------|
|  **Index:**    |  0  |  1  |        2       |  3   |         4        |

```py
NestedT =(1, 2, ("pop", "rock") ,(3,4),("disco",(1,2)))

# Print element on each index
print("Element 0 of Tuple: ", NestedT[0])
print("Element 1 of Tuple: ", NestedT[1])
print("Element 2 of Tuple: ", NestedT[2])
print("Element 3 of Tuple: ", NestedT[3])
print("Element 4 of Tuple: ", NestedT[4])
```

Will output:
```
Element 0 of Tuple:  1
Element 1 of Tuple:  2
Element 2 of Tuple:  ('pop', 'rock')
Element 3 of Tuple:  (3, 4)
Element 4 of Tuple:  ('disco', (1, 2))
```

To access the nested tuples the sub-indexes are referred to, it is useful imagine the indexes as a tree structure:  


```mk
Root/index:
0       ├── 1
1       ├── 2
2       ├── ("pop", "rock")
2.0     │       ├── "pop"
2.1     │       └── "rock"
3       ├── (3, 4)
3.0     │       ├── 3
3.1     │       └── 4
4       └── ("disco", (1, 2))
4.0             ├── "disco"
4.1             └── (1, 2)
4.1.0               ├── 1
4.0.1               └── 2
```

To print these the index address can be referred to
```md
| Full Index     | Value    |
|----------------|----------|
| [0]            | 1        |
| [1]            | 2        |
| [2][0]         | "pop"    |
| [2][1]         | "rock"   |
| [3][0]         | 3        |
| [3][1]         | 4        |
| [4][0]         | "disco"  |
| [4][1][0]      | 1        |
| [4][1][1]      | 22       |
```

```py
NestedT =(1, 2, ("pop", "rock") ,(3,4),("disco",(1,22)))

# Print element on each index, including nest indexes
print("Element 2, 0 of Tuple: ",   NestedT[2][0])
print("Element 2, 1 of Tuple: ",   NestedT[2][1])
print("Element 3, 0 of Tuple: ",   NestedT[3][0])
print("Element 3, 1 of Tuple: ",   NestedT[3][1])
print("Element 4, 0 of Tuple: ",   NestedT[4][0])
print("Element 4, 1 of Tuple: ",   NestedT[4][1])
```

Will output:
```
Element 2, 0 of Tuple:  pop
Element 2, 1 of Tuple:  rock
Element 3, 0 of Tuple:  3
Element 3, 1 of Tuple:  4
Element 4, 0 of Tuple:  disco
Element 4, 1 of Tuple:  (1, 22)
```

Strings in the second nested tuples can be accessed using a third index:
```py
# Print the first element in the second nested tuples
NestedT[2][1][0]

# Print the second element in the second nested tuples
NestedT[2][1][1]
```

Will output:
```
'r'
'o'
```

Similarly, the elements nested deeper in the tree can be accessed with a third index:
```py
# Print the first element in the second nested tuples
NestedT[4][1][0]

# Print the second element in the second nested tuples
NestedT[4][1][1]
```

Will output:
```
1
22
```

___
## Tuple Exercises

**Exercise 1:**  
Consider the following tuple:
```py
# sample tuple
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
```

Find the length of the tuple, `genres_tuple`:
<details><summary>Click here for the solution</summary>

```py
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
len(genres_tuple)
```

Will output:  
```
8
```
</details>

___
**Exercise 2:**  
Consider the following tuple:
```py
# sample tuple
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
```

Access the element, with respect to index 3: 

<details><summary>Click here for the solution</summary>

```py
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
genres_tuple[3]
```

Will output:  
```
'hard rock'
```
</details>

___
**Exercise 3:**   
Consider the following tuple:
```py
# sample tuple
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
```

Use slicing to obtain indexes 3, 4 and 5:

<details><summary>Click here for the solution</summary>

```py
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
genres_tuple[3:6]
```

Will output:  
```
('hard rock', 'soft rock', 'R&B')
```
</details>

___
**Exercise 4:**  
Consider the following tuple:
```py
# sample tuple
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
```

Find the first two elements of the tuple `genres_tuple`:

<details><summary>Click here for the solution</summary>

```py
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
genres_tuple[0:2]
```

Will output:  
```
('pop', 'rock')
```
</details>

___
**Exercise 5:**  
Consider the following tuple:
```py
# sample tuple
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
```

Find the first index of `"disco"`:

<details><summary>Click here for the solution</summary>

```py
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", "R&B", "progressive rock", "disco") 
genres_tuple.index("disco")
```

Will output:  
```
7
```
</details>

___
**Exercise 6:**  
Generate a sorted list from the tuple `C_tuple=(-5, 1, -3)`:

<details><summary>Click here for the solution</summary>

```py
C_tuple = (-5, 1, -3)
C_list = sorted(C_tuple)
C_list
```

Will output:  
```
[-5, -3, 1]
```
</details>

___
## Lists

### Objectives:

*  Perform list operations in Python, including indexing, list manipulation, and copy/clone list.

<h2>Table of Contents</h2>
<li>About the Dataset</li>
<li>Lists</li>
  <ul>
      <li>Indexing</li>
      <li>List Content</li>
      <li>List Operations</li>
      <li>Copy and Clone List</li>
  </ul>
<li>Quiz on Lists</li>
___

Immutable Output: The sorted() function returns a new list and does not modify the original iterable. If you want an in-place sort for lists, use the .sort() method instead.

A list is represented with square brackets, in many respects lists are like tuples, one key difference is they are mutable.
Lists can contain strings, floats, integers.
We can nest other lists.
We also nest tuples and other data structures; the same indexing conventions apply for nesting.
Like tuples, each element of a list can be accessed via an index.
The following table represents the relationship between the index and the elements in the
list.
The first element can be accessed by the name of the list followed by a square bracket with
the index number, in this case zero.
We can access the second element as follows.
We can also access the last element.
In Python, we can use a negative index.
The relationship is as follows.
The corresponding indexes are as follows.
We can also perform slicing in lists.
For example, if we want the last two elements in this list we use the following command.
Notice how the last index is 1 larger than the length of the list.
The index conventions for lists and tuples are identical.
Check the labs for more examples.
We can concatenate or combine lists by adding them.
The result is the following.
The new list has the following indices.
Lists are mutable, therefore, we can change them.
For example, we apply the method extends by adding a "dot" followed by the name of the
method, then parenthesis.
The argument inside the parenthesis is a new list that we are going to concatenate to the
original list.
In this case, instead of creating a new list, L1, the original list L is modified by adding
two new elements.
To learn more about methods check out our video on objects and classes.
Another similar method is append.
If we apply append instead of extended we add one element to the list.
If we look at the index, there is only one more element.
Index 3 contains the list we appended.
Every time we apply a method, the lists changes.
If we apply extend, we add two new elements to the list.
The list L is modified by adding two new elements.
If we append the string �A�, we further change the list adding the string �A�.
As lists are mutable, we can change them.
For example, we can change the first element as follows.
The list now becomes: �hard rock�, 10, 1.2.
We can delete an element of a list using the "del" command; we simply indicate the list
item we would like to remove as an argument.
For example, if we would like to remove the first element, the result becomes 10,1.2.
We can delete the second element.
This operation removes the second element of the list.
We can convert a string to a list using split.
For example, the method split converts every group of characters separated by a space into
an element of a list.
We can use the split function to separate strings on a specific character, known as
a delimiter.
We simply pass the delimiter we would like to split on as an argument, in this case a
comma.
The result is a list, each element corresponds to a set of characters that have been separated
by a comma.
When we set one variable, B equal to A, both A and B are referencing the same list.
Multiple names referring to the same object is known as aliasing.
We know from the last slide that the first element in B is set as hard rock.
If we change the first element in �A� to �banana� we get a side effect; the
value of B will change as a consequence.
"A" and �B� are referencing the same list, therefore if we change "A�, list "B" also
changes.
If we check the first element of B after changing list �A� we get banana instead of hard
rock.
You can clone list �A� by using the following syntax.
Variable "A" references one list.
Variable �B� references a new copy or clone of the original list.
Now if you change �A�, "B" will not change.
We can get more info on lists, tuples and many other objects in Python using the help
command.
Simply pass in the list, tuple or any other Python object.
See the labs for more things you can do with lists.*

### Indexing

We are going to take a look at lists in Python. A list is a sequenced collection of different objects such as integers, strings, and even other lists as well. The address of each element within a list is called an `index`. An index is used to access and refer to items within a list.

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsIndex.png" width="1000">

 To create a list, type the list within square brackets `[ ]`, with your content inside the parenthesis and separated by commas. Let’s try it!
```py
# Create a list
L = ["Michael Jackson", 10.1, 1982]
L
```

We can use negative and regular indexing with a list:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsNeg.png" width="1000">

```py
# Print the elements on each index
print('the same element using negative and positive indexing:\n Postive:',L[0],
'\n Negative:' , L[-3]  )
print('the same element using negative and positive indexing:\n Postive:',L[1],
'\n Negative:' , L[-2]  )
print('the same element using negative and positive indexing:\n Postive:',L[2],
'\n Negative:' , L[-1]  )
```

<h3 id="content">List Content</h3>

Lists can contain strings, floats, and integers. We can nest other lists, and we can also nest tuples and other data structures. The same indexing conventions apply for nesting:    
```py
# Sample List
["Michael Jackson", 10.1, 1982, [1, 2], ("A", 1)]
```

<h3 id="op">List Operations</h3>

 We can also perform slicing in lists. For example, if we want the last two elements, we use the following command:
```py
# Sample List
L = ["Michael Jackson", 10.1,1982,"MJ",1]
L
```

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsSlice.png" width="1000">

```py
# List slicing
L[3:5]
```

We can use the method `extend` to add new elements to the list:
```py
# Use extend to add elements to list
L = [ "Michael Jackson", 10.2]
L.extend(['pop', 10])
L
```

Another similar method is `append`. If we apply `append` instead of `extend`, we add one element to the list:
```py
# Use append to add elements to list
L = [ "Michael Jackson", 10.2]
L.append(['pop', 10])
L
```

 Each time we apply a method, the list changes. If we apply `extend` we add two new elements to the list. The list `L` is then modified by adding two new elements:
```py
# Use extend to add elements to list
L = [ "Michael Jackson", 10.2]
L.extend(['pop', 10])
L
```

If we append the list  `['a','b']` we have one new element consisting of a nested list:
```py
# Use append to add elements to list
L.append(['a','b'])
L
```

As lists are mutable, we can change them. For example, we can change the first element as follows:
```py
# Change the element based on the index
A = ["disco", 10, 1.2]
print('Before change:', A)
A[0] = 'hard rock'
print('After change:', A)
```

 We can also delete an element of a list using the `del` command:
```py
# Delete the element based on the index
print('Before change:', A)
del(A[0])
print('After change:', A)
```

We can convert a string to a list using `split`.  For example, the method `split` translates every group of characters separated by a space into an element in a list:
```py
# Split the string, default is by space
'hard rock'.split()
```

We can use the split function to separate strings on a specific character which we call a **delimiter**. We pass the character we would like to split on into the argument, which in this case is a comma.  The result is a list, and each element corresponds to a set of characters that have been separated by a comma: 
```py
# Split the string by comma
'A,B,C,D'.split(',')
```

<h3 id="co">Copy and Clone List</h3>

When we set one variable `B` equal to `A`, both `A` and `B` are referencing the same list in memory:
```py
# Copy (copy by reference) the list A
A = ["hard rock", 10, 1.2]
B = A
print('A:', A)
print('B:', B)
```

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsRef.png" width="1000" align="center">

Initially, the value of the first element in `B` is set as "hard rock". If we change the first element in `A` to `"banana"`, we get an unexpected side effect.  As `A` and `B` are referencing the same list, if we change list `A`, then list `B` also changes. If we check the first element of `B` we get "banana" instead of "hard rock":
```py
# Examine the copy by reference
print('B[0]:', B[0])
A[0] = "banana"
print('B[0]:', B[0])
```

This is demonstrated in the following figure: 

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsRefGif.gif" width="1000">

You can clone list **A** by using  the following syntax:
```py
# Clone (clone by value) the list A
B = A[:]
B
```

 Variable **B** references a new copy or clone of the original list. This is demonstrated in the following figure:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsVal.gif" width="1000">

Now if you change `A`, `B` will not change: 
```py
print('B[0]:', B[0])
A[0] = "hard rock"
print('B[0]:', B[0])
```

### Quiz on Lists
1  
Create a list `a_list`, with the following elements `1`, `hello`, `[1,2,3]` and `True`. 

<details><summary>Click here for the solution</summary>

```py
a_list = [1, 'hello', [1, 2, 3] , True]
a_list
```

</details>
2  
Find the value stored at index 1 of `a_list`.

<details><summary>Click here for the solution</summary>

```py
a_list[1]
```

</details>

3  
Retrieve the elements stored at index 1, 2 and 3 of `a_list`.

<details><summary>Click here for the solution</summary>

```py
a_list[1:4]

```

</details>

Concatenate the following lists `A = [1, 'a']` and `B = [2, 1, 'd']`:

<details><summary>Click here for the solution</summary>

```py
A = [1, 'a'] 
B = [2, 1, 'd']
A + B
```

</details>

___

**Task 12: Conditionals and Lists**  
Create a script that generates a list of random numbers (between 1 and 100) of a specified length. Then, use conditionals to categorize the numbers into "even" and "odd" groups. Print the resulting lists.  





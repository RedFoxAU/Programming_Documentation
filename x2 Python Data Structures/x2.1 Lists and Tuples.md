### 2.1 **Lists and Tuples**


### Objectiveso:

*  Perform list operations in Python, including indexing, list manipulation, and copy/clone list.

<h2>Table of Contents</h2>
<li>About the Dataset</li>
<li>Lists</li>
  <ul>
      <li>Indexing</li>
      <li>List Content</li>
      <li>List Operations</li>
      <li>Copy and Clone List</li>
  </ul>
<li>Quiz on Lists</li>

___
### Lists

These are called compound data types and are one of the key types of data structures in Python.


*Lists are also a popular data structure in Python.
Lists are also an ordered sequence.
Here is a list L. A list is represented with square brackets.
In many respects lists are like tuples, one key difference is they are mutable.
Lists can contain strings, floats, integers.
We can nest other lists.
We also nest tuples and other data structures; the same indexing conventions apply for nesting.
Like tuples, each element of a list can be accessed via an index.
The following table represents the relationship between the index and the elements in the
list.
The first element can be accessed by the name of the list followed by a square bracket with
the index number, in this case zero.
We can access the second element as follows.
We can also access the last element.
In Python, we can use a negative index.
The relationship is as follows.
The corresponding indexes are as follows.
We can also perform slicing in lists.
For example, if we want the last two elements in this list we use the following command.
Notice how the last index is 1 larger than the length of the list.
The index conventions for lists and tuples are identical.
Check the labs for more examples.
We can concatenate or combine lists by adding them.
The result is the following.
The new list has the following indices.
Lists are mutable, therefore, we can change them.
For example, we apply the method extends by adding a "dot" followed by the name of the
method, then parenthesis.
The argument inside the parenthesis is a new list that we are going to concatenate to the
original list.
In this case, instead of creating a new list, L1, the original list L is modified by adding
two new elements.
To learn more about methods check out our video on objects and classes.
Another similar method is append.
If we apply append instead of extended we add one element to the list.
If we look at the index, there is only one more element.
Index 3 contains the list we appended.
Every time we apply a method, the lists changes.
If we apply extend, we add two new elements to the list.
The list L is modified by adding two new elements.
If we append the string �A�, we further change the list adding the string �A�.
As lists are mutable, we can change them.
For example, we can change the first element as follows.
The list now becomes: �hard rock�, 10, 1.2.
We can delete an element of a list using the "del" command; we simply indicate the list
item we would like to remove as an argument.
For example, if we would like to remove the first element, the result becomes 10,1.2.
We can delete the second element.
This operation removes the second element of the list.
We can convert a string to a list using split.
For example, the method split converts every group of characters separated by a space into
an element of a list.
We can use the split function to separate strings on a specific character, known as
a delimiter.
We simply pass the delimiter we would like to split on as an argument, in this case a
comma.
The result is a list, each element corresponds to a set of characters that have been separated
by a comma.
When we set one variable, B equal to A, both A and B are referencing the same list.
Multiple names referring to the same object is known as aliasing.
We know from the last slide that the first element in B is set as hard rock.
If we change the first element in �A� to �banana� we get a side effect; the
value of B will change as a consequence.
"A" and �B� are referencing the same list, therefore if we change "A�, list "B" also
changes.
If we check the first element of B after changing list �A� we get banana instead of hard
rock.
You can clone list �A� by using the following syntax.
Variable "A" references one list.
Variable �B� references a new copy or clone of the original list.
Now if you change �A�, "B" will not change.
We can get more info on lists, tuples and many other objects in Python using the help
command.
Simply pass in the list, tuple or any other Python object.
See the labs for more things you can do with lists.*

### Indexing

We are going to take a look at lists in Python. A list is a sequenced collection of different objects such as integers, strings, and even other lists as well. The address of each element within a list is called an `index`. An index is used to access and refer to items within a list.

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsIndex.png" width="1000">

 To create a list, type the list within square brackets `[ ]`, with your content inside the parenthesis and separated by commas. Let’s try it!
```py
# Create a list
L = ["Michael Jackson", 10.1, 1982]
L
```

We can use negative and regular indexing with a list:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsNeg.png" width="1000">

```py
# Print the elements on each index
print('the same element using negative and positive indexing:\n Postive:',L[0],
'\n Negative:' , L[-3]  )
print('the same element using negative and positive indexing:\n Postive:',L[1],
'\n Negative:' , L[-2]  )
print('the same element using negative and positive indexing:\n Postive:',L[2],
'\n Negative:' , L[-1]  )
```

<h3 id="content">List Content</h3>

Lists can contain strings, floats, and integers. We can nest other lists, and we can also nest tuples and other data structures. The same indexing conventions apply for nesting:    
```py
# Sample List
["Michael Jackson", 10.1, 1982, [1, 2], ("A", 1)]
```

<h3 id="op">List Operations</h3>

 We can also perform slicing in lists. For example, if we want the last two elements, we use the following command:
```py
# Sample List
L = ["Michael Jackson", 10.1,1982,"MJ",1]
L
```

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsSlice.png" width="1000">

```py
# List slicing
L[3:5]
```

We can use the method `extend` to add new elements to the list:
```py
# Use extend to add elements to list
L = [ "Michael Jackson", 10.2]
L.extend(['pop', 10])
L
```

Another similar method is `append`. If we apply `append` instead of `extend`, we add one element to the list:
```py
# Use append to add elements to list
L = [ "Michael Jackson", 10.2]
L.append(['pop', 10])
L
```

 Each time we apply a method, the list changes. If we apply `extend` we add two new elements to the list. The list `L` is then modified by adding two new elements:
```py
# Use extend to add elements to list
L = [ "Michael Jackson", 10.2]
L.extend(['pop', 10])
L
```

If we append the list  `['a','b']` we have one new element consisting of a nested list:
```py
# Use append to add elements to list
L.append(['a','b'])
L
```

As lists are mutable, we can change them. For example, we can change the first element as follows:
```py
# Change the element based on the index
A = ["disco", 10, 1.2]
print('Before change:', A)
A[0] = 'hard rock'
print('After change:', A)
```

 We can also delete an element of a list using the `del` command:
```py
# Delete the element based on the index
print('Before change:', A)
del(A[0])
print('After change:', A)
```

We can convert a string to a list using `split`.  For example, the method `split` translates every group of characters separated by a space into an element in a list:
```py
# Split the string, default is by space
'hard rock'.split()
```

We can use the split function to separate strings on a specific character which we call a **delimiter**. We pass the character we would like to split on into the argument, which in this case is a comma.  The result is a list, and each element corresponds to a set of characters that have been separated by a comma: 
```py
# Split the string by comma
'A,B,C,D'.split(',')
```

<h3 id="co">Copy and Clone List</h3>

When we set one variable `B` equal to `A`, both `A` and `B` are referencing the same list in memory:
```py
# Copy (copy by reference) the list A
A = ["hard rock", 10, 1.2]
B = A
print('A:', A)
print('B:', B)
```

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsRef.png" width="1000" align="center">

Initially, the value of the first element in `B` is set as "hard rock". If we change the first element in `A` to `"banana"`, we get an unexpected side effect.  As `A` and `B` are referencing the same list, if we change list `A`, then list `B` also changes. If we check the first element of `B` we get "banana" instead of "hard rock":
```py
# Examine the copy by reference
print('B[0]:', B[0])
A[0] = "banana"
print('B[0]:', B[0])
```

This is demonstrated in the following figure: 

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsRefGif.gif" width="1000">

You can clone list **A** by using  the following syntax:
```py
# Clone (clone by value) the list A
B = A[:]
B
```

 Variable **B** references a new copy or clone of the original list. This is demonstrated in the following figure:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/ListsVal.gif" width="1000">

Now if you change `A`, `B` will not change: 
```py
print('B[0]:', B[0])
A[0] = "hard rock"
print('B[0]:', B[0])
```

### Quiz on Lists
1  
Create a list `a_list`, with the following elements `1`, `hello`, `[1,2,3]` and `True`. 

<details><summary>Click here for the solution</summary>

```py
a_list = [1, 'hello', [1, 2, 3] , True]
a_list
```

</details>
2  
Find the value stored at index 1 of `a_list`.

<details><summary>Click here for the solution</summary>

```py
a_list[1]
```

</details>

3  
Retrieve the elements stored at index 1, 2 and 3 of `a_list`.

<details><summary>Click here for the solution</summary>

```py
a_list[1:4]

```

</details>

Concatenate the following lists `A = [1, 'a']` and `B = [2, 1, 'd']`:

<details><summary>Click here for the solution</summary>

```py
A = [1, 'a'] 
B = [2, 1, 'd']
A + B
```

</details>

___
### Tuples

*These are called compound data types and are one of the key types of data structures in Python.
Tuples Tuples are an ordered sequence.
Here is a Tuple �Ratings.�
Tuples are expressed as comma-separated elements within parentheses.
These are values inside the parentheses.
In Python, there are different types: strings, integer, float.
They can all be contained in a tuple, but the type of the variable is tuple.
Each element of a tuple can be accessed via an index.
The following table represents the relationship between the index and the elements in the
tuple.
The first element can be accessed by the name of the tuple followed by a square bracket
with the index number, in this case, zero.
We can access the second element as follows.
We can also access the last element.
In Python, we can use negative index.
The relationship is as follows.
The corresponding values are shown here.
We can concatenate or combine tuples by adding them.
The result is the following with the following index.
If we would like multiple elements from a tuple, we could also slice tuples.
For example, if we want the first three elements, we use the following command.
The last index is 1 larger than the index you want.
Similarly, if we want the last two elements, we use the following command.
Notice how the last index is 1 larger than the length of the tuple.
We can use the �len� command to obtain the length of a tuple.
As there are 5 elements, the result is five.
Tuples are immutable, which means we can't change them.
To see why this is important, let's see what happens when we set the variable Ratings 1
to ratings.
Let's use the image to provide a simplified explanation of what�s going on.
Each variable does not contain a tuple, but references the same immutable tuple object.
See the �objects and classes� module for more about objects.
Let's say we want to change the element at index 2.
Because tuples are immutable, we can't.
Therefore, Ratings 1 will not be affected by a change in Rating because the tuple is
immutable i.e., we can't change it.
We can assign a different tuple to the Ratings variable.
The variable Ratings now references another tuple.
As a consequence of immutability, if we would like to manipulate a tuple, we must create
a new tuple instead.
For example, if we would like to sort a tuple, we use the function sorted.
The input is the original tuple.
The output is a new sorted tuple.
For more on functions, see our video on functions.
A tuple can contain other tuples as well as other complex data types; this is called nesting.
We can access these elements using the standard indexing methods.
If we select an index with a tuple, the same index convention applies.
As such, we can then access values in the tuple.
For example, we could access the second element.
We can apply this indexing directly to the tuple variable NT.
It is helpful to visualize this as a tree.
We can visualize this nesting as a tree.
The tuple has the following indexes.
If we consider indexes with other tuples, we see the tuple at index 2 contains a tuple
with two elements.
We can access those two indexes.
The same convention applies to index 3.
We can access the elements in those tuples as well.
We can continue the process.
We can even access deeper levels of the tree by adding another square bracket.
We can access different characters in the string or various elements in the second tuple
contained in the first.*


## Objectives

After completing this lab you will be able to:

* Perform the basics tuple operations in Python, including indexing, slicing and sorting

<h2>Table of Contents</h2>
<div class="alert alert-block alert-info" style="margin-top: 20px">
    <ul>
        <li>
            <a href="#dataset">About the Dataset</a>
        </li>
        <li>
            <a href="#tuple">Tuples</a>
            <ul>
                <li><a href="index">Indexing</a></li>
                <li><a href="slice">Slicing</a></li>
                <li><a href="sort">Sorting</a></li>
            </ul>
        </li>
        <li>
            <a href="#escape">Quiz on Tuples</a>
        </li>
    </ul>
 
</div>

<hr>

In Python, there are different data types: string, integer, and float. These data types can all be contained in a tuple as follows:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesType.png" width="750" align="center">

Now, let us create your first tuple with string, integer and float.
```py
# Create your first tuple
tuple1 = ("disco",10,1.2 )
tuple1
The type of variable is a **tuple**. 

# Print the type of the tuple you created
type(tuple1)
```

<h3 id="index">Indexing</h3>

 Each element of a tuple can be accessed via an index. The following table represents the relationship between the index and the items in the tuple. Each element can be obtained by the name of the tuple followed by a square bracket with the index number:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesIndex.gif" width="750" align="center">

We can print out each value in the tuple:
```py
# Print the variable on each index
print(tuple1[0])
print(tuple1[1])
print(tuple1[2])
```

We can print out the **type** of each value in the tuple:
```
# Print the type of value on each index
print(type(tuple1[0]))
print(type(tuple1[1]))
print(type(tuple1[2]))
```

We can also use negative indexing. We use the same table above with corresponding negative values:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesNeg.png" width="750" align="center">

We can obtain the last element as follows (this time we will not use the print statement to display the values):
```py
# Use negative index to get the value of the last element
tuple1[-1]
```

We can display the next two elements as follows:
```py
# Use negative index to get the value of the second last element
tuple1[-2]

# Use negative index to get the value of the third last element
tuple1[-3]
```

<h3 id="concate">Concatenate Tuples</h3>

We can concatenate or combine tuples by using the **+** sign:
```
# Concatenate two tuples
tuple2 = tuple1 + ("hard rock", 10)
tuple2
```

We can slice tuples obtaining multiple values as demonstrated by the figure below:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesSlice.gif" width="750" align="center">

<h3 id="slice">Slicing</h3>

We can slice tuples, obtaining new tuples with the corresponding elements: 
```py
# Slice from index 0 to index 2
tuple2[0:3]
```

We can obtain the last two elements of the tuple:
```py
# Slice from index 3 to index 4
tuple2[3:5]
```

We can obtain the length of a tuple using the length command: 
```py
# Get the length of tuple
len(tuple2)
```

This figure shows the number of elements:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesElement.png" width="750" align="center">

<h3 id="sort">Sorting</h3>

Consider the following tuple:
```py
# A sample tuple
Ratings = (0, 9, 6, 5, 10, 8, 9, 6, 2)
```

We can sort the values in a tuple and save it to a new tuple: 
```py
# Sort the tuple
RatingsSorted = sorted(Ratings)
RatingsSorted
```

<h3 id="nest">Nested Tuple</h3>

A tuple can contain another tuple as well as other more complex data types. This process is called 'nesting'. Consider the following tuple with several elements: 

# Create a nest tuple
```py
NestedT =(1, 2, ("pop", "rock") ,(3,4),("disco",(1,2)))
```

Each element in the tuple, including other tuples, can be obtained via an index as shown in the figure:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesNestOne.png" width="750" align="center">
```py
# Print element on each index
print("Element 0 of Tuple: ", NestedT[0])
print("Element 1 of Tuple: ", NestedT[1])
print("Element 2 of Tuple: ", NestedT[2])
print("Element 3 of Tuple: ", NestedT[3])
print("Element 4 of Tuple: ", NestedT[4])
```

We can use the second index to access other tuples as demonstrated in the figure:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesNestTwo.png" width="750" align="center">

 We can access the nested tuples:
```py
# Print element on each index, including nest indexes
print("Element 2, 0 of Tuple: ",   NestedT[2][0])
print("Element 2, 1 of Tuple: ",   NestedT[2][1])
print("Element 3, 0 of Tuple: ",   NestedT[3][0])
print("Element 3, 1 of Tuple: ",   NestedT[3][1])
print("Element 4, 0 of Tuple: ",   NestedT[4][0])
print("Element 4, 1 of Tuple: ",   NestedT[4][1])
```

We can access strings in the second nested tuples using a third index:
```py
# Print the first element in the second nested tuples
NestedT[2][1][0]

# Print the second element in the second nested tuples
NestedT[2][1][1]
```

 We can use a tree to visualise the process. Each new index corresponds to a deeper level in the tree:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesNestThree.gif" width="750" align="center">

Similarly, we can access elements nested deeper in the tree with a third index:
```py
# Print the first element in the second nested tuples
NestedT[4][1][0]

# Print the second element in the second nested tuples
NestedT[4][1][1]
```

The following figure shows the relationship of the tree and the element `NestedT[4][1][1]`:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesNestFour.gif" width="750" align="center">

<h2 id="quiz">Quiz on Tuples</h2>

1   
Consider the following tuple:
```py
# sample tuple
genres_tuple = ("pop", "rock", "soul", "hard rock", "soft rock", \
                "R&B", "progressive rock", "disco") 
genres_tuple
```

Find the length of the tuple, `genres_tuple`:

<img src="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%202/images/TuplesQuiz.png" width="1100" align="center">

<details><summary>Click here for the solution</summary>

```py
len(genres_tuple)
```

</details>

2  
Access the element, with respect to index 3: 

<details><summary>Click here for the solution</summary>

```py
genres_tuple[3]
```

</details>

3  
Use slicing to obtain indexes 3, 4 and 5:

<details><summary>Click here for the solution</summary>

```py
genres_tuple[3:6]
```

</details>

4  
Find the first two elements of the tuple `genres_tuple`:

<details><summary>Click here for the solution</summary>

```py
genres_tuple[0:2]
```

</details>

5  
Find the first index of `"disco"`:

<details><summary>Click here for the solution</summary>

```py
genres_tuple.index("disco")
```

</details>

6  
Generate a sorted List from the Tuple `C_tuple=(-5, 1, -3)`:

<details><summary>Click here for the solution</summary>

```py
C_tuple = (-5, 1, -3)
C_list = sorted(C_tuple)
C_list
```

</details>

**Task 12: Conditionals and Lists**  
Create a script that generates a list of random numbers (between 1 and 100) of a specified length. Then, use conditionals to categorize the numbers into "even" and "odd" groups. Print the resulting lists.  